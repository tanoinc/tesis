
\subsection{Infraestructura del \eng{backend}}
\label{marco_teorico}

En la arquitectura del \eng{sofware} existen muchas capas entre el usuario y el procesador físico que ejecuta las instrucciones. Una de ellas, es la denominada como \eng{backend}. Esta capa es la que se encarga de manejar la lógica de negocios y el almacenamiento, y su ejecución se hará del lado del servidor.

En las siguientes secciones analizaremos las características técnicas requeridas por las necesidades planteadas en la introducción de ese capítulo, que justifiquen las decisiones para este desarrollo (en relación con el \eng{backend}).

\subsubsection{Sistemas distribuidos}
\label{sistemas_distribuidos}

Al comienzo de la era de las computadoras modernas, entre 1945 y 1985, estas eran muy costosas y de gran tamaño. Además operaban independientemente unas de otras.

A mediados de los años 80, ocurrieron dos avances tecnológicos claves que resultaron en el comienzo de una nueva era para favorecer el desarrollo de los sistemas distribuidos\cite{artnoema}. 

El primero es el avance en la potencia de los microprocesadores: se produjo un gran aumento del poder de cómputo y a su vez una considerable reducción en su precio. Esto fue tan vertiginoso que, como indica Tanembaum, \comillas{si los autos hubieran mejorado a este ritmo en el mismo período de tiempo, un \textit{Rolls Royce} hoy hubiera costado 1 dólar y obtendríamos un billón de millas por galón. Desafortunadamente, también sería probable que tuviera un manual de 200 páginas explicando cómo abrir la puerta}\cite{tanenbaum2007distributed}.

El segundo avance se trata de la aparición de las redes de alta velocidad: desde las redes de área local, hasta las redes de área amplia, permitieron que miles de computadoras se conecten entre sí. Con velocidades variantes, han ido evolucionando desde unos pocos Kilobits hasta Gigabits por segundo.

En conclusión, estos dos factores hacen que hoy sea posible desarrollar fácilmente sistemas que integren a múltiples computadoras que interactúan a través de redes de alta velocidad.
Estos sistemas y su interacción definen un sistema distribuido.

Tanembaum y Van Steen definen a los sistemas distribuidos como \comillas{una colección independiente de computadoras que se muestran a sus usuarios como un único sistema coherente}\cite[p.~2]{tanenbaum2007distributed}. De esta manera especifican que sus principales objetivos son:

\begin{itemize}
\item Hacer que los recursos remotos estén disponibles de manera controlada y eficiente.
\item Ocultar que procesos y recursos están físicamente dispersos entre computadoras distintas.
\item Ser abiertos. Esto significa que el acceso a sus servicios esté establecido por ciertas reglas estándar que definan su sintaxis y su semántica.
\item Ser escalables. Esto es que tenga la posibilidad de crecer sin perder calidad en el servicio.
\end{itemize}

Estos objetivos serán requerimientos primordiales para llevar a cabo la integración de los servicios de la Universidad con la aplicación móvil.

\paragraph{Servicios Web}
\label{servicios_web}

Según la definición de la \gls{uddi}, los Servicios Web son \comillas{aplicaciones modulares, auto-contenidas que tienen interfaces abiertas, orientadas a Internet y basadas en estándares}\cite{uddi2001uddi}. 

En términos generales, son la manera de exponer información y funcionalidad de un sistema a través de tecnologías Web, respetando sus estándares. El uso de estos es clave, ya que reduce la heterogeneidad existente entre sistemas facilitando su integración\cite{alonso2004web}.Esto nos permite utilizar los estándares Web como medio para comunicar sistemas. 

Por estas razones se considera a los servicios Web como interfaz para realizar la comunicación de las aplicaciones de la Universidad.
En las siguientes secciones se revisan los distintos tipos de servicios web, describiendo sus principales características.

\paragraph{SOAP}
\label{soap}

\gls{soap} define un protocolo de envío de información estructurada, con un tipo asociado y de manera descentralizada utilizando como lenguaje \gls{XML}\cite{box2000simple}. Estos datos pueden viajar sobre protocolos de transporte existentes como \gls{http} o \gls{smtp}.

Un mensaje en \gls{soap} consta de un elemento \comillas{sobre} (en inglés \eng{Envelope}) que dentro contiene otros dos elementos: un encabezado (\eng{header}) y un cuerpo(\eng{body}). Con esta estructura básica, ya es posible la comunicación.

\begingroup
  \xmlfile{src/codigo/02-capitulo-2/soap.xml}
  \captionof{listing}{Ejemplo de estructura básica de mensaje XML en \gls{soap}. \eng{Envelope} tiene dos hijos: \eng{header} y \eng{body}.\label{codigo_soap}}
\endgroup

Por otra parte, \gls{soap} define un modelo que le permite indicar a los receptores del mensaje cómo deben procesarlo. Modela el concepto de \textit{actor} que es quien sabe qué parte del mensaje le corresponde y cual descartar para enviar al siguiente.

Sus servicios permiten especificar un documento \gls{WSDL} (en formato \gls{XML}) utilizado para detallar la interfaz de conexión, brindando información al usuario sobre los parámetros y sus tipos de dato.

Las fortalezas de \gls{soap}\cite{pautasso2008restful} son:

\begin{itemize}
\item Transparencia e independencia respecto del protocolo de transporte.
\item El uso de \gls{WSDL} para describir la interfaz del servicio ayuda a abstraer detalles del protocolo de comunicación y serialización, así como también cuestiones de la plataforma sobre el que está implementado (y el lenguaje utilizado).
\end{itemize}

Sus debilidades:

\begin{itemize}
\item Permite la existencia de problemas de interoperabilidad cuando se filtran tipos de datos nativos o construcciones del lenguaje en la interfaz, atravesando las capas de abstracción.
\item Produce un \textit{desajuste de impedancia} que resulta costoso al traducir los datos en formato \gls{XML} a datos utilizados en lenguajes orientados a objetos.
\end{itemize}

\paragraph{REST}
\label{rest}

\gls{rest}\cite{fielding2000rest} es una arquitectura de servicios (cliente-servidor) que se basa en los estándares de la Web. En ella, los datos y las funciones son considerados recursos y estos son accedidos mediante \gls{uri}. Las acciones sobre estos recursos son las definidas por los verbos del protocolo \gls{http}: GET, POST, PUT, DELETE (entre otros). A las \gls{api} que implementan la arquitectura \gls{rest}, se les dicen que son \gls{restful}.

De esta forma, su diseño fomenta que lo servicios sean simples, livianos y performantes.

Sus fortalezas son\cite{pautasso2008restful}:
\begin{itemize}
\item Su sencillez: al utilizar estándares web (\gls{http}, \gls{uri}, \gls{mime}, \gls{json}, \gls{XML}) definidos por la \gls{w3c} e \gls{ietf}, la infraestructura necesaria para su implementación, es de uso generalizado.
\item Servidores y clientes \gls{http} están disponibles para la mayoría de los lenguajes de programación, sistemas operativos y plataformas. Además el puerto 80 generalmente se deja abierto en cualquier configuración de \eng{firewall}.
\item Infraestructura liviana y económica.
\item Fácilmente escalable gracias a que soporta caché, balance de carga y \gls{clustering}.
\item Permite formatos de mensajes livianos como \gls{json} o inclusive texto plano para tipo de datos simples.
\end{itemize}

Sus debilidades son:
\begin{itemize}
\item Su implementación, al ser abierta, a veces no se adapta al correcto uso de los verbos \gls{http}.
\item Para solicitudes idempotentes (utilizando el verbo \eng{GET}), existe una limitación en el tamaño de la \gls{uri} de 4KB.
\end{itemize}

\paragraph{SOAP o REST: Conclusión}
\label{soap_vs_rest}

En base a las ventajas y desventajas de ambas tecnologías, se realizó un análisis\cite[p.~809]{pautasso2008restful} y se concluyó que es conveniente utilizar \gls{rest} para integrar servicios a medida a través de la Web y preferir \gls{soap} en la integración de aplicaciones de negocio y que posean como requisito la calidad de servicio.

En base a lo analizado se concluye que la utilización de servicios \gls{rest} es conveniente para este desarrollo puesto que: provee mayor flexibilidad, es más liviana, sus tecnologías son de uso generalizado y se adapta correctamente a las necesidades de conexión de los dispositivos móviles y de otros servicios externos que consuman la información provista. Además facilita la posibilidad de escalar horizontalmente y permite el uso de caché.

Por otra parte, para la comunicación con aplicaciones móviles, \gls{rest} supera ampliamente a \gls{soap}. Una evaluación hecha\cite{hamad2010performance} demostró que \gls{rest} tuvo una mejor \eng{performance} debido a mensajes de menor tamaño y tiempos de respuesta más cortos, además de su alta flexibilidad y bajo \eng{overhead}. 

En conclusión, se recomienda la utilización de servicios RESTful\cite{hamad2010performance} para la conexión entre el \eng{backend} y el dispositivo.

\paragraph{Diseño de una API RESTful}
\label{caracteristicas_api_restful}

Para la comunicación con otras aplicaciones utilizando \gls{rest} es necesario definir una \gls{api} \gls{restful} que cumpla con sus características\cite{fielding2000rest}. Estas son:
\begin{itemize}
\item \textbf{Sin estado}: No debe almacenar información de contexto del cliente. Todos los datos que sean necesarios para la comunicación, se envían en cada pedido \gls{http}, inclusive los datos de autenticación (para el caso de acceso a recursos restringidos). Esto es así para favorecer la escalabilidad y por ende la \eng{performance} general de los servicios: la ausencia de estados en el servidor, elimina la necesidad de sincronizar los datos de sesión entre los distintos nodos\cite{rodriguez2008restful}.

\item \textbf{Orientada a recursos}: La \textit{arquitectura orientada a recursos} se basa sobre el concepto del \textit{recurso}. Esto significa que cada uno de ellos es un componente distribuido que permite ser accedido directamente y es manejado a través de una interfaz común estándar\cite{lucchi2008resource}. Cómo acceder a ellos y qué acciones realizar, se tratarán en los dos siguientes puntos.

\item \textbf{Acceso mediante \glspl{uri}}: En \gls{http} y en particular para los servicios web \gls{rest}, la \gls{uri} es la principal interfaz de manipulación de los datos. Por lo tanto, para ser correcta, debe ser auto-descriptiva: que de manera intuitiva se pueda predecir, o al menos saber dónde buscar, el acceso al recurso. Una manera para lograr esto es definiendo \glspl{uri} en base a una estructura jerárquica (de forma similar a la organización de los directorios). De esta forma, existe una rama principal y de ella heredan sub-ramas que van exponiendo cada uno de los servicios. Se utiliza como caracter de separación la \comillas{barra inclinada}.

\item \textbf{Uso de métodos \gls{http}}: Las acciones que se realicen sobre los recursos deben ser representadas a través de los \comillas{verbos \gls{http}} (definidos en el estándar como \textit{métodos \gls{http}}). Existe una asociación directa entre \gls{crud} y las operaciones \gls{http}\cite{fielding2000rest}. Además, cada una de ellas tiene una semántica asociada que implica un comportamiento implícito en la \gls{api} (pero bien definido en el estándar \gls{http}). Por ejemplo el método \gls{metodo_get} es idempotente, lo que significa que no importa cuantas veces sea invocado, siempre retornará los mismos resultados y no producirá una modificación explícita (esperada por el usuario) en el sistema.
\item \textbf{Representación de los recursos en \gls{XML} o \gls{json}}: la representación de un recurso refleja el estado de este y sus atributos al momento de su solicitud. La manera en que esta información es codificada es lo que llamamos formato. Comúnmente se utilizan dos formatos \gls{XML} y \gls{json}. Ninguno es superior al orto y su elección depende de las necesidades del sistema. 

En particular, para la presente solución, que no requiere la existencia de datos complejos, se hace el foco en \gls{json}. Este es más simple (legible) y compacto (menos \eng{overhead}) y por ende su transferencia en la red es más rápida. Su uso en soluciones que utilizan \gls{javascript} y \gls{ajax} es más eficiente y flexible\cite{maeda2012performance}.

\item \textbf{Estado de respuesta utilizando códigos  \gls{http}}: estos códigos son devueltos siempre en una solicitud \gls{http} y están definidos dentro del estándar\cite{fielding2014hypertext}. Si bien no indican demasiado en dentro del dominio de aplicación, se vuelven útiles cuando son utilizados por un destinatario o intermediario genérico (como cachés, proxies o librerías), que comprende el protocolo y sabe cómo actuar ante ciertas respuestas.

\item \textbf{Versionable}: el versionado no está dentro de las recomendaciones o de la especificación, de hecho va en contra del \comillas{purismo de \gls{rest}} y es muy discutida la forma de llevarlo a cabo. Sin embargo, existe una realidad: como el \eng{software} cambia, también lo hacen sus \glspl{api}, por lo tanto es un aspecto importante a destacar en su diseño. 

A medida que el software evoluciona surge la necesidad de incorporar estos cambios en los servicios. Si estos se hicieran y no se tomase ningún recaudo, se estarían generando incompatibilidades en sistemas que dependen de estos servicios. Para evitar estos problemas, surge la necesidad del versionado de \glspl{api}.

Como indica Hunt en su artículo\cite{ApiVersion}, existen tres maneras \comillas{incorrectas} de versionar \glspl{api}:
\begin{itemize}
\item Por \gls{url}: Incorporando el número de versión en la \gls{uri}.
\item Encabezado personalizado: Se crea un encabezado \gls{http} personalizado indicando la versión de la \gls{api} del \eng{request}.
\item Encabezado \eng{Accept}: Similar al punto anterior, pero este está definido en el estándar sólo que se le incorpora el dato de la versión.
\end{itemize}

\end{itemize}

\subsubsection{Autorización y autenticación}
\label{autorizacion_autenticacion}

Al definirse la utilización de servicios \gls{rest} para la comunicación, el siguiente paso es determinar qué mecanismos de seguridad existen, que sean compatibles y utilizados por la industria, para restringir el acceso a los recursos.

Se denomina \textit{autenticación} al proceso de determinar que algo o alguien es quien dice ser y \textit{autorización} a la verificación de los permisos necesarios para acceder a un recurso\cite{authAuth}.

El desarrollo propuesto requerirá que se verifique el acceso a la información de:
\begin{itemize}
\item los usuarios a través de la aplicación  móvil y 
\item de las aplicaciones y servicios externos que quieran integrar su información.
\end{itemize}
Para ello se revisarán los mecanismos que más se adecuen para cada caso.

En el siguiente apartado, se investigan las tecnologías para realizar la autorización y autenticación de las diferentes partes intervinientes. 

Para la interacción entre aplicaciones externas y la \gls{api}: se adopta el mecanismo de clave de \gls{api} y clave secreta.

Para la interacción entre la aplicación móvil y la\gls{api}: se utiliza el protocolo estándar denominado OAuth, en su segunda versión (OAuth 2.0).

A continuación se detallan las características de cada una.

\paragraph{OAuth2}
\label{oauth}

El protocolo OAuth2 permite verificar que las aplicaciones tengan los permisos necesarios para el acceso a los datos y operaciones en nombre del usuario, sin estas conocer sus credenciales (nombre de usuario y contraseña, por ejemplo)\cite{hardt2012oauth}.

Este mecanismo además, posibilita la integración entre las aplicaciones sin compartir o guardar los datos de acceso. Para ello se vale del concepto de tokens de acceso de manera que el usuario no tenga que ingresar la clave en aplicaciones de terceros.

Oauth2 es ideal para asegurar \glspl{api} ya que permite autenticar usuarios mediante tokens desde dispositivos sobre los cuales no se tiene confianza\cite{degges2015ApiSecurity}. 

Para el caso de esta tesina, se utiliza OAuth2 para la interacción de la aplicación móvil con la \gls{api} \gls{restful}, manteniendo las restricciones que esta impone.




\paragraph{API Key y API Secret}
\label{apikey}
